This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: **/*.svg
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
eslint.config.mjs
next.config.ts
package.json
postcss.config.mjs
README.md
src/api/cart.ts
src/api/products.ts
src/app/(main)/page.tsx
src/app/(main)/products/[slug]/loading.tsx
src/app/(main)/products/[slug]/page.tsx
src/app/globals.css
src/app/layout.tsx
src/app/loading.tsx
src/components/AddToCartButton.tsx
src/components/CartSidebar.tsx
src/components/Header.tsx
src/components/ProductCard.tsx
src/context/CartContext.tsx
src/lib/types.ts
src/types/cocart.d.ts
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="eslint.config.mjs">
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;
</file>

<file path="next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  images: {
    remotePatterns: [
      {
        protocol: "https",
        hostname: "7ringsstore.com",
        port: "",
        pathname: "/store/wp-content/uploads/**",
      },
    ],
  },
};

export default nextConfig;
</file>

<file path="package.json">
{
  "name": "7rings-headless-frontend",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "react": "19.1.0",
    "react-dom": "19.1.0",
    "next": "15.4.5"
  },
  "devDependencies": {
    "typescript": "^5",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "@tailwindcss/postcss": "^4",
    "tailwindcss": "^4",
    "eslint": "^9",
    "eslint-config-next": "15.4.5",
    "@eslint/eslintrc": "^3"
  }
}
</file>

<file path="postcss.config.mjs">
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;
</file>

<file path="src/api/cart.ts">
import { CoCartResponse } from "@/types/cocart";

// This should be the base URL of your Node.js backend
const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL;

// NEW: Function to get the cart from your backend
export const getCart = async (): Promise<CoCartResponse> => {
  if (!API_BASE_URL) {
    throw new Error("API Base URL (NEXT_PUBLIC_API_URL) is not defined in environment variables.");
  }
  
  const apiUrl = `${API_BASE_URL}/cart`;

  try {
    const response = await fetch(apiUrl, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
      },
      credentials: 'include', // Important: sends cookies with the request
    });

    const data = await response.json();

    if (!response.ok) {
      throw new Error(data.message || 'Failed to fetch cart');
    }

    return data as CoCartResponse;
  } catch (error) {
    console.error('Error fetching cart:', error);
    throw error;
  }
};


export const addToCart = async (productId: string | number): Promise<CoCartResponse> => {
  if (!API_BASE_URL) {
    throw new Error("API Base URL (NEXT_PUBLIC_API_URL) is not defined in environment variables.");
  }

  const apiUrl = `${API_BASE_URL}/cart/add-item`;

  try {
    const response = await fetch(apiUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        id: String(productId),
        quantity: "1", // You can make this dynamic if needed
      }),
      // This tells the browser to send cookies (like the cart_key) with this API request.
      credentials: 'include', 
    });

    const data = await response.json();

    if (!response.ok) {
      throw new Error(data.message || 'Failed to add item to cart');
    }

    return data as CoCartResponse;
  } catch (error) {
    console.error('Error adding to cart:', error);
    throw error;
  }
};
</file>

<file path="src/api/products.ts">
import { Product } from "@/lib/types";

const API_URL = process.env.NEXT_PUBLIC_WOOCOMMERCE_URL;

async function fetcher<T>(url: string, options: RequestInit = {}): Promise<T> {
  const headers = {
    "Content-Type": "application/json",
    ...options.headers,
  };

  try {
    const response = await fetch(url, {
      ...options,
      headers,
      next: { revalidate: 10 },
    });

    if (!response.ok) {
      const errorBody = await response.json();
      throw new Error(
        errorBody.message || "An error occurred while fetching data."
      );
    }
    return response.json();
  } catch (error) {
    console.error("API Fetch Error:", error);
    throw error;
  }
}

export async function getProducts(): Promise<Product[]> {
  return fetcher<Product[]>(`${API_URL}/get-products`);
}

// NEW FUNCTION: To find a single product by its ID
export async function getProductById(id: number): Promise<Product | null> {
    try {
        console.log(`[API] Fetching all products to find ID: ${id}`);
        const products = await getProducts();
        const product = products.find((p) => p.id === id);

        if (!product) {
          console.warn(`[API] Product with ID ${id} not found.`);
          return null;
        }

        console.log(`[API] Found product:`, product);
        return product;
    } catch (error) {
        console.error(`[API] Error fetching product by ID ${id}:`, error);
        return null;
    }
}
</file>

<file path="src/app/(main)/page.tsx">
import { getProducts } from "@/api/products";
import { ProductCard } from "@/components/ProductCard";

export default async function HomePage() {
  const products = await getProducts();

  if (!products || products.length === 0) {
    return <p>No products found.</p>;
  }

  return (
    <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
      {products.map((product) => (
        <ProductCard key={product.id} product={product} />
      ))}
    </div>
  );
}
</file>

<file path="src/app/(main)/products/[slug]/loading.tsx">
export default function ProductLoading() {
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 gap-8 lg:gap-12 animate-pulse">
      {/* Image Skeleton */}
      <div className="aspect-square w-full rounded-lg bg-neutral-200 dark:bg-neutral-800"></div>

      {/* Details Skeleton */}
      <div className="flex flex-col gap-4 py-4">
        <div className="h-10 w-3/4 rounded bg-neutral-200 dark:bg-neutral-700"></div>
        <div className="h-8 w-1/4 rounded bg-neutral-200 dark:bg-neutral-700"></div>
        <div className="mt-4 space-y-3">
          <div className="h-4 w-full rounded bg-neutral-200 dark:bg-neutral-700"></div>
          <div className="h-4 w-full rounded bg-neutral-200 dark:bg-neutral-700"></div>
          <div className="h-4 w-5/6 rounded bg-neutral-200 dark:bg-neutral-700"></div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/app/globals.css">
@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}
</file>

<file path="src/app/loading.tsx">
export default function Loading() {
  return (
    <div className="flex justify-center items-center h-screen">
      <div className="animate-spin rounded-full h-32 w-32 border-t-2 border-b-2 border-blue-500"></div>
    </div>
  );
}
</file>

<file path="src/components/CartSidebar.tsx">
"use client";

import Image from "next/image";
import { useCart } from "@/context/CartContext";

// Helper function to format currency
const formatPrice = (priceString: string | number) => {
  const price = Number(priceString);
  if (isNaN(price)) {
    // Fallback for pre-formatted HTML strings if any
    return { __html: String(priceString) };
  }

  // Example for USD. Change 'en-US' and currency 'USD' as needed.
  const formattedPrice = new Intl.NumberFormat("en-US", {
    style: "currency",
    currency: "USD",
    minimumFractionDigits: 2, // This controls the decimal places
  }).format(price);

  return { __html: formattedPrice };
};

export function CartSidebar() {
  const { cart, isCartSidebarOpen, closeCartSidebar } = useCart();
  const checkoutUrl = process.env.NEXT_PUBLIC_CHECKOUT_URL;

  if (!isCartSidebarOpen) return null;

  return (
    <>
      {/* Overlay */}
      <div
        className="fixed inset-0 bg-black/50 z-20"
        onClick={closeCartSidebar}
      />

      {/* Sidebar */}
      <aside className="fixed top-0 right-0 h-full w-full max-w-sm bg-background z-30 flex flex-col">
        <div className="flex items-center justify-between p-4 border-b">
          <h2 className="text-xl font-semibold">Shopping Cart</h2>
          <button
            onClick={closeCartSidebar}
            className="p-2 rounded-full hover:bg-neutral-100 dark:hover:bg-neutral-800"
          >
            &times;
          </button>
        </div>

        {cart && cart.items.length > 0 ? (
          <div className="flex-1 overflow-y-auto p-4">
            <ul className="divide-y">
              {cart.items.map((item) => (
                <li
                  key={item.item_key}
                  className="flex items-center gap-4 py-4"
                >
                  <div className="relative h-20 w-20 rounded-md overflow-hidden border">
                    <Image
                      src={item.featured_image || "/placeholder.svg"}
                      alt={item.name}
                      fill
                      className="object-cover"
                    />
                  </div>
                  <div className="flex-1">
                    <p className="font-semibold">{item.name}</p>
                    <p className="text-sm text-foreground/70">
                      Quantity: {item.quantity.value}
                    </p>
                  </div>
                  <p
                    className="font-medium"
                    dangerouslySetInnerHTML={formatPrice(item.price)}
                  />
                </li>
              ))}
            </ul>
          </div>
        ) : (
          <div className="flex-1 flex items-center justify-center">
            <p>Your cart is empty.</p>
          </div>
        )}

        {cart && cart.items.length > 0 && (
          <div className="border-t p-4 space-y-4">
            <div className="flex justify-between font-bold text-lg">
              <span>Subtotal:</span>
              {/* UPDATED SUBTOTAL DISPLAY */}
              <span
                dangerouslySetInnerHTML={formatPrice(cart.totals.subtotal)}
              />
            </div>
            <a
              href={checkoutUrl}
              className="block w-full text-center bg-green-600 text-white font-bold py-3 px-6 rounded-lg transition-colors hover:bg-green-700"
            >
              Proceed to Checkout
            </a>
          </div>
        )}
      </aside>
    </>
  );
}
</file>

<file path="src/lib/types.ts">
export interface ProductImage {
  id: number;
  src: string;
  name: string;
  alt: string;
}

export interface Product {
  id: number;
  name: string;
  slug: string;
  permalink: string;
  description: string;
  short_description: string;
  price: string;
  regular_price: string;
  sale_price: string;
  on_sale: boolean;
  images: ProductImage[];
  stock_status: "instock" | "outofstock";
  price_html?: string; // Optional price_html for consistency
}
</file>

<file path="src/types/cocart.d.ts">
// A single item in the cart
export interface CoCartItem {
  item_key: string;
  id: number;
  name: string;
  title: string;
  price: string;
  featured_image?: string; // NEW: Add optional featured_image
  quantity: {
    value: number;
    min_purchase: number;
    max_purchase: number;
  };
  totals: {
    subtotal: number;
    subtotal_tax: number;
    total: number;
    tax: number;
  };
  slug: string;
}

// The entire cart response from CoCart
export interface CoCartResponse {
  items: CoCartItem[];
  item_count: number;
  totals: {
    subtotal: string;
    subtotal_tax: string;
    fee_total: string;
    fee_tax: string;
    discount_total: string;
    discount_tax: string;
    shipping_total: string;
    shipping_tax: string;
    total: string;
  };
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="README.md">
I'm building a headless eCommerce frontend using Next.js with the App Router, located inside the src/app directory. The backend is powered by WooCommerce, hosted on a subdirectory (/store) of the same domain. I'm using CoCart to manage the shopping cart for guest users by handling sessions and cart data through the WooCommerce REST API. The frontend allows users to browse products, view product details, and add items to the cart. However, the checkout process is not handled on the frontend — users are redirected to the native WooCommerce checkout page. Authentication is not implemented at this stage. The project uses Tailwind CSS for styling, Context API for global state (cart), and follows a modular structure with clean separation between components, context, and API layers. This setup is designed to be scalable and reusable as a template for future eCommerce projects.



This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
</file>

<file path="src/app/(main)/products/[slug]/page.tsx">
import { getProductById } from "@/api/products";
import { notFound } from "next/navigation";
import Image from "next/image";
import AddToCartButton from "@/components/AddToCartButton";

interface ProductPageProps {
  params: {
    slug: string;
  };
}

export default async function ProductPage({ params }: ProductPageProps) {
  const productId = parseInt(params.slug, 10);

  if (isNaN(productId)) {
    notFound();
  }

  const product = await getProductById(productId);

  if (!product) {
    notFound();
  }

  const primaryImage = product.images?.[0]?.src || "/placeholder.svg";

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 gap-8 lg:gap-12">
      {/* Product Image */}
      <div className="relative aspect-square w-full">
        <Image
          src={primaryImage}
          alt={product.name}
          fill
          className="object-cover rounded-lg border"
          priority
        />
      </div>

      {/* Product Details */}
      <div className="flex flex-col gap-4 py-4">
        <h1 className="text-3xl lg:text-4xl font-bold">{product.name}</h1>
        <p
          className="text-2xl font-semibold text-foreground"
          dangerouslySetInnerHTML={{
            __html: product.price_html || `Rs ${product.price}`,
          }}
        />
        <div
          className="prose dark:prose-invert max-w-none mb-4"
          dangerouslySetInnerHTML={{ __html: product.description }}
        />
        
        {/* UPDATED LOGIC: Changed from '===' to '!==' to handle null status */}
        {product.stock_status !== "outofstock" ? (
          <AddToCartButton productId={product.id} />
        ) : (
          <p className="mt-4 text-lg font-bold text-red-500">Out of Stock</p>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/app/layout.tsx">
import type { Metadata } from "next";
import { Geist } from "next/font/google";
import "./globals.css";
import { Header } from "@/components/Header";
import { CartProvider } from "@/context/CartContext"; // NEW
import { CartSidebar } from "@/components/CartSidebar"; // NEW

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "7Rings Headless Store",
  description: "An eCommerce store built with Next.js and WooCommerce.",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={`${geistSans.variable} font-sans antialiased`}>
        <CartProvider> {/* NEW: Wrap everything in the CartProvider */}
          <Header />
          <CartSidebar /> {/* NEW: Render the sidebar globally */}
          <main className="container mx-auto p-4 sm:p-6 md:p-8">{children}</main>
        </CartProvider>
      </body>
    </html>
  );
}
</file>

<file path="src/components/AddToCartButton.tsx">
"use client";

import { useState } from "react";
import { addToCart } from "../api/cart";
import { useCart } from "@/context/CartContext";

interface AddToCartButtonProps {
  productId: number | string;
}

const AddToCartButton: React.FC<AddToCartButtonProps> = ({ productId }) => {
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const { updateCart, openCartSidebar } = useCart();

  const handleAddToCart = async (
    event: React.MouseEvent<HTMLButtonElement>
  ) => {
    event.preventDefault();
    event.stopPropagation();

    setLoading(true);
    setError(null);

    try {
      const cartData = await addToCart(productId);
      updateCart(cartData);
      openCartSidebar();
    } catch (err: unknown) {
      if (err instanceof Error) {
        setError(err.message);
      } else {
        setError("An unknown error occurred.");
      }
    } finally { // --- START OF FIX ---
      setLoading(false); // This ensures the button state is always reset
    } 
  };

  return (
    <>
      <button
        onClick={handleAddToCart}
        disabled={loading}
        className="w-full px-6 py-3 bg-blue-600 text-white font-semibold rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors"
      >
        {loading ? "Adding..." : "Add to Cart"}
      </button>

      {error && (
        <p className="text-red-500 text-xs mt-2 text-center">{error}</p>
      )}
    </>
  );
};

export default AddToCartButton;
</file>

<file path="src/components/Header.tsx">
"use client";

import Link from "next/link";
import { useCart } from "@/context/CartContext"; // NEW

export function Header() {
  const { cart, openCartSidebar, loading } = useCart(); // NEW

  return (
    <header className="sticky top-0 bg-background/80 backdrop-blur-md z-10">
      <nav className="container mx-auto flex items-center justify-between p-4 border-b">
        <Link
          href="/"
          className="text-xl font-bold hover:opacity-80 transition-opacity"
        >
          7Rings Store
        </Link>

        {/* NEW: Cart button with item count */}
        <button
          onClick={openCartSidebar}
          className="relative rounded-full p-2 transition-colors hover:bg-neutral-100 dark:hover:bg-neutral-800"
          aria-label="Open cart"
        >
          {/* A simple shopping bag icon */}
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <path d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z"></path>
            <line x1="3" y1="6" x2="21" y2="6"></line>
            <path d="M16 10a4 4 0 0 1-8 0"></path>
          </svg>

          {!loading && cart && cart.item_count > 0 && (
            <span className="absolute -top-1 -right-1 flex h-5 w-5 items-center justify-center rounded-full bg-blue-600 text-xs font-bold text-white">
              {cart.item_count}
            </span>
          )}
        </button>
      </nav>
    </header>
  );
}
</file>

<file path="src/components/ProductCard.tsx">
'use client';

import Link from "next/link";
import Image from "next/image";
import { Product } from "@/lib/types";
import AddToCartButton from "./AddToCartButton";

interface ProductCardProps {
  product: Product;
}

export function ProductCard({ product }: ProductCardProps) {
  const primaryImage = product.images[0]?.src;

  return (
    <div className="group block overflow-hidden rounded-lg border transition-shadow hover:shadow-lg flex flex-col">
      <Link href={`/products/${product.id}`} className="block">
        <div className="relative aspect-square w-full bg-neutral-100 dark:bg-neutral-800">
          {primaryImage && (
            <Image
              src={primaryImage}
              alt={product.name}
              fill
              className="object-cover transition-transform group-hover:scale-105"
            />
          )}
        </div>
        <div className="p-4">
          <h3 className="truncate text-lg font-semibold">{product.name}</h3>
          <p
            className="text-foreground/80"
            dangerouslySetInnerHTML={{
              __html: product.price_html || `${product.price} USD`,
            }}
          />
        </div>
      </Link>

      <div className="mt-auto p-4 pt-0">
        {/* UPDATED LOGIC: Changed from '===' to '!==' to handle null status */}
        {product.stock_status !== 'outofstock' ? (
          <AddToCartButton productId={product.id} />
        ) : (
          <button
            disabled
            className="w-full px-6 py-3 bg-gray-500 text-white font-semibold rounded-lg cursor-not-allowed"
          >
            Out of Stock
          </button>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/context/CartContext.tsx">
'use client';

import { createContext, useContext, useState, ReactNode, useEffect, useCallback } from 'react';
import { CoCartResponse } from '@/types/cocart';
import { getCart } from '@/api/cart'; 

interface ICartContext {
  cart: CoCartResponse | null;
  loading: boolean;
  isCartSidebarOpen: boolean;
  updateCart: (cartData: CoCartResponse) => void;
  openCartSidebar: () => void;
  closeCartSidebar: () => void;
}

const CartContext = createContext<ICartContext | null>(null);

interface CartProviderProps {
  children: ReactNode;
}

export const CartProvider: React.FC<CartProviderProps> = ({ children }) => {
  const [cart, setCart] = useState<CoCartResponse | null>(null);
  const [loading, setLoading] = useState<boolean>(true); // Set initial loading to true
  const [isCartSidebarOpen, setIsCartSidebarOpen] = useState(false);

  // This function fetches the initial cart state from the backend
  const fetchInitialCart = useCallback(async () => {
    setLoading(true);
    try {
      const cartData = await getCart();
      setCart(cartData);
    } catch (error) {
      console.error("Failed to fetch initial cart:", error);
      // Set a default empty cart structure on failure
      setCart({ items: [], item_count: 0, totals: { subtotal: '0', subtotal_tax: '0', fee_total: '0', fee_tax: '0', discount_total: '0', discount_tax: '0', shipping_total: '0', shipping_tax: '0', total: '0' } });
    } finally {
      setLoading(false);
    }
  }, []);

  // UseEffect to run the fetch function once when the component mounts
  useEffect(() => {
    fetchInitialCart();
  }, [fetchInitialCart]);


  const updateCart = (cartData: CoCartResponse) => {
    setCart(cartData);
  };

  const openCartSidebar = () => setIsCartSidebarOpen(true);
  const closeCartSidebar = () => setIsCartSidebarOpen(false);

  return (
    <CartContext.Provider value={{ cart, loading, updateCart, isCartSidebarOpen, openCartSidebar, closeCartSidebar }}>
      {children}
    </CartContext.Provider>
  );
};

export const useCart = (): ICartContext => {
  const context = useContext(CartContext);
  if (!context) {
    throw new Error('useCart must be used within a CartProvider');
  }
  return context;
};
</file>

</files>
